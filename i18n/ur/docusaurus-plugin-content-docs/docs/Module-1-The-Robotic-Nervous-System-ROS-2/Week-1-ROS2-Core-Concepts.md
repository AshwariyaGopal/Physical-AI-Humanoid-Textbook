---
id: week-1-ros2-core-concepts
title: Week 1 ROS2 Core Concepts
---

## ROS 2 Topics: Asynchronous Data Streams

In ROS 2, **Topics** are the primary mechanism for asynchronous, many-to-many communication between nodes. Think of a Topic like a public announcement system or a radio station: a node can "broadcast" information (publish) without knowing who is listening, and any interested node can "tune in" (subscribe) to receive that information. This pattern is ideal for continuous data streams like sensor readings, joint states, or diagnostic information.

### Data Flow and Message Types

Data communicated over Topics are organized into **messages**. Each Topic has a specific *message type* associated with it, which defines the structure and data fields of the information being sent. For example, a `sensor_msgs/msg/LaserScan` message type would define fields for laser scan data, while a `std_msgs/msg/String` message type would simply contain a string. Both publishers and subscribers for a given topic *must* agree on the message type. This ensures data consistency and proper interpretation.

### Quality of Service (QoS) Settings

ROS 2 introduces **Quality of Service (QoS) policies** to provide more control over how messages are exchanged between nodes. QoS settings allow you to configure aspects like reliability, message history, and durability, which are crucial for different application needs.

For instance:
-   **Reliability**: Do you need every message to be delivered (reliable) or is it okay to drop some messages if the network is congested (best effort)?
-   **History**: Should the subscriber receive past messages when it first connects (keep all) or only recent ones (keep last)?
-   **Durability**: Should a publisher make its last message available to late-joining subscribers (transient local) or only send to active subscribers (volatile)?

These settings enable ROS 2 to cater to a wide range of use cases, from high-frequency sensor data that can tolerate occasional loss, to critical command messages that require guaranteed delivery.

### Publishers: Broadcasting Information

A **Publisher** node is responsible for sending messages on a specific topic. It creates instances of the defined message type, fills them with data, and then "publishes" them. Other nodes (subscribers) can then receive these messages.

Here's an example of an `rclpy` publisher node:

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy
from std_msgs.msg import String
import sys
import time

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        # Define a QoS Profile for demonstration
        # BEST_EFFORT means messages might be dropped if network is congested
        # KEEP_LAST with depth 1 means only the most recent message is stored
        # VOLATILE durability means messages are not persisted
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
            durability=DurabilityPolicy.VOLATILE
        )
        self.publisher_ = self.create_publisher(String, 'topic', qos_profile)
        self.i = 0
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.get_logger().info(f'Publisher node "{self.get_name()}" started. Publishing on topic "topic".')

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2! Count: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    try:
        rclpy.spin(minimal_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        minimal_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Subscribers: Receiving Information

A **Subscriber** node listens for messages on a particular topic. When a message is published on that topic, the subscriber receives it and processes it using a callback function. This allows nodes to react to events or data generated by other parts of the ROS 2 system.
